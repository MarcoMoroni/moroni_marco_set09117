% #######################################
% ########### FILL THESE IN #############
% #######################################
\def\mytitle{Coursework Report}
\def\mykeywords{algorithms, data structures, Python, checkers, draughts}
\def\myauthor{Marco Moroni}
\def\contact{40213873@live.napier.ac.uk}
\def\mymodule{Algorithms \& Data Structures  (SET09117)}
% #######################################
% #### YOU DON'T NEED TO TOUCH BELOW ####
% #######################################
\documentclass[10pt, a4paper]{article}
\usepackage[a4paper,outer=1.5cm,inner=1.5cm,top=1.75cm,bottom=1.5cm]{geometry}
\twocolumn
\usepackage{graphicx}
\graphicspath{{./images/}}
%colour our links, remove weird boxes
\usepackage[colorlinks,linkcolor={black},citecolor={blue!80!black},urlcolor={blue!80!black}]{hyperref}
%Stop indentation on new paragraphs
\usepackage[parfill]{parskip}
%% Arial-like font
\IfFileExists{uarial.sty}
{
    \usepackage[english]{babel}
    \usepackage[T1]{fontenc}
    \usepackage{uarial}
    \renewcommand{\familydefault}{\sfdefault}
}{
    \GenericError{}{Couldn't find Arial font}{ you may need to install 'nonfree' fonts on your system}{}
    \usepackage{lmodern}
    \renewcommand*\familydefault{\sfdefault}
}
%Napier logo top right
\usepackage{watermark}
%Lorem Ipusm dolor please don't leave any in you final report ;)
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
%give us the Capital H that we all know and love
\usepackage{float}
%tone down the line spacing after section titles
\usepackage{titlesec}
%Cool maths printing
\usepackage{amsmath}
%PseudoCode
\usepackage{algorithm2e}

\titlespacing{\subsection}{0pt}{\parskip}{-3pt}
\titlespacing{\subsubsection}{0pt}{\parskip}{-\parskip}
\titlespacing{\paragraph}{0pt}{\parskip}{\parskip}
\newcommand{\figuremacro}[5]{
    \begin{figure}[#1]
        \centering
        \includegraphics[width=#5\columnwidth]{#2}
        \caption[#3]{\textbf{#3}#4}
        \label{fig:#2}
    \end{figure}
}

\lstset{
	escapeinside={/*@}{@*/}, language=C++,
	basicstyle=\fontsize{8.5}{12}\selectfont,
	numbers=left,numbersep=2pt,xleftmargin=2pt,frame=tb,
    columns=fullflexible,showstringspaces=false,tabsize=4,
    keepspaces=true,showtabs=false,showspaces=false,
    backgroundcolor=\color{white}, morekeywords={inline,public,
    class,private,protected,struct},captionpos=t,lineskip=-0.4em,
	aboveskip=10pt, extendedchars=true, breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941}
}

\thiswatermark{\centering \put(336.5,-38.0){\includegraphics[scale=0.8]{logo}} }
\title{\mytitle}
\author{\myauthor\hspace{1em}\\\contact\\Edinburgh Napier University\hspace{0.5em}-\hspace{0.5em}\mymodule}
\date{}
\hypersetup{pdfauthor=\myauthor,pdftitle=\mytitle,pdfkeywords=\mykeywords}
\sloppy
% #######################################
% ########### START FROM HERE ###########
% #######################################
\begin{document}
    \maketitle
    \begin{abstract}
        The goal of this coursework is to implement the classic board game of checkers in an arbitrary computer language demonstrating a correct use of data structures. The language chosen here is Python and the game can be played from the console.
    \end{abstract}
    
    \textbf{Keywords -- }{\mykeywords}
    
    \section{Introduction}
    This report aims to describe the implementation of a checkers game. It was important to use the correct data structures in the code, trying to make it as efficient as possible. The game was coded in using Python.
       
    \section{Implementation}
    
    \subsection{Overwiew}
    The board is made by a 2D list, in which every item can be either empty or a piece. \\
    Every piece know its \textit{rank} (man or king) and what player they belong to. \\
    Moves are recorded in a stack called \texttt{moves}, which is used when undoing. There is another similar stack, \texttt{redoMoves}, used to store moves that can be redone. \\
    The game uses a while loop as a game loop. This loop runs until there is a winner. \\
    Finally, the AI works by choosing random moves.
    
    \subsection{Board}
    This project started by creating a simple board made by a 2D array. In Python this is archived by using a list of lists, which means a list of rows where each row is a list os sqaures. \\
    There are 8 rows and 8 columns and each sqaure of the board is initially empty (\texttt{None} in Python).
    
    \subsection{Pieces}
    In checkers a piece can be:
    \begin{itemize}
    	\item either black or white;
    	\item either a man or a king.
    \end{itemize}
	Considering that, the game uses a \texttt{Piece} class that knows:
	\begin{itemize}
		\item its player (of type \texttt{Player});
		\item its \textit{rank}, that is wheter it is a man or a king.
	\end{itemize}
	The ranks are enumerated elements of a class \texttt{PieceRank}: the values are \texttt{PieceRank.MAN} and \texttt{PieceRank.KING}.
	Initially, a piece also knew its position it had at the beginning of the game. This information could have been used in an early version of the \texttt{replay} funtion, where there was a board reset to its inital state. Later on this information became useless, because \texttt{replay} now resets the board by undoing every move.
	
	\subsection{Players}
	A player is normally identified by being either black or white. In this implementation, a player is an instance of a class \texttt{Player}. This class has:
	\begin{itemize}
		\item a dictionary of symbols (\textit{symbols} are the characters printed in the console to represent a piece). The keys are \texttt{PieceRank}s and the values are a character (eg. a white/black dot for men, or a white/black sqaure for kings);
		\item a boolean \texttt{isFacingUp}. This is used in two occasions: when setting up the pieces (see section \ref{subsubsec:prelude} \textit{Prelude}) and when getting all the legal displacements of a piece (see section \ref{subsec:gettinglegalmoves} \textit{Getting legal moves});
		\item a boolean \texttt{cpu};
		\item all the functions used by AI (called when the player is not human) (see \textit{AI}).
	\end{itemize}

	\subsection{Printing the board}
	The function \texttt{printBoard} simply print a symbol for every sqaure where there is a \texttt{Piece}. It will print one of the two symbols (man or king) stored in the player class of the piece

	\subsection{Moves}
	Every move is an instance of the class \texttt{Move}. This class stores the \texttt{originPosition} of the moved piece, the \texttt{displacement} (\((\pm1, \pm1)\) or \((\pm2, \pm2)\)), the eventual \texttt{pieceEaten} and a boolean \texttt{doesBecomeKing}. \\
	Initially \texttt{pieceEaten} was not present, but knowing only if the displacement is \((\pm2, \pm2)\) is not enogh when undoing a move. It would be easy to just create another piece of the opponent player when recreating an eaten piece, but there would be no way to know what rank it used to be.
	
	\subsection{Storing moves}
	Moves are stored in a Python list \texttt{moves} considered as a stack: when performed, a move gets pushed in and when undone, it gets popped out. Another stack has been added later, \texttt{redoMoves}, which is used to store moves that can be redone. \\
	The program works with these 2 stacks by following 3 rules:
	\begin{enumerate}
		\item every time a move is performed, tis move gets pushed to \texttt{moves} and \texttt{redoMoves} is emptied;
		\item when undoing the last move \texttt{m}, \texttt{m} get popped from \texttt{moves} and pushed to \texttt{redoMoves};
		\item when redoing a move \texttt{m}, \texttt{m} get popped from \texttt{redoMoves} and pushed to \texttt{moves}.
	\end{enumerate}
	
	\subsection{Undo}
	When the function \texttt{undo} is called the steps in algorithm \ref{alg:undo}.
	\begin{algorithm}[h]
		\label{alg:undo}
		move = moves.pop()
		redoMoves.push(move)
		undo piece position
		\If{move.displacement == \((\pm2, \pm2)\)}{
			restore piece eaten in \((\pm1, \pm1)\)
		}
		\If{move.doesBecomeKing}{
			piece.undoBecomingKing
		}
		\caption{\texttt{undo}}
	\end{algorithm}
	There was a problem with this function: if one of the players was not human the following scenario would happen:
	\begin{enumerate}
		\item it's turn 5: human player choose to undo;
		\item it's now cpu player's turn: it moves a piece;
		\item it's turn 5 again and human player did not actually undo her move;
	\end{enumerate}
	To fix this situation \texttt{undo} can take one argument that corresponds to the number of moves a player wants to undo. The only change to implement this was to put algorithm \ref{alg:undo} inisde a \texttt{for} loop.
	
	\subsection{Redo}
	\texttt{redo} is very similar to \texttt{undo}, as you can see in algorithm \ref{alg:redo}.
	\begin{algorithm}[h]
		\label{alg:redo}
		move = redoMoves.pop()
		moves.push(move)
		redo piece position
		\If{move.displacement == \((\pm2, \pm2)\)}{
			eat piece in \((\pm1, \pm1)\)
		}
		\If{move.doesBecomeKing}{
			piece.becomesKing
		}
		\caption{\texttt{redo}}
	\end{algorithm}
	And like \texttt{undo}, the whole algorithm is inside a for loop that iterates as many times as the player want to.
	
	\subsection{Replay}
	\texttt{replay} is quite simple. It first undo everything and then it redo everything (but in slightly different ways). As shown in alogrithm \ref{alg:replay}, while \texttt{undo} is called only once (it undo the whole game), \texttt{redo} gets called once for each move and every time the board is printed. In this way the user can see all the moves made in chronological order, just like the game is being replayed.
	\begin{algorithm}[h]
		\label{alg:replay}
		totalNumberOfMoves = len(moves)
		undo(totalNumberOfMoves)
		printBoard()
		\For{$i = 0$ \KwTo totalNumberOfMoves}{
			redo()
			printBoard()
			wait some time
		}
		\caption{\texttt{replay}}
	\end{algorithm}
	
	\subsection{Getting legal moves}
	\label{subsec:gettinglegalmoves}
	This is the function that implements most of the rules of the board game. \\
	It is called \texttt{getLegalDisplacements} because it returns a list of all the legal displacements (\((\pm1, \pm1)\) or \((\pm2, \pm2)\)) a piece can move by. It has 2 arguments:
	\begin{itemize}
		\item the coordinates of the piece to be considered;
		\item a boolean \texttt{mustEat}.
	\end{itemize}
	This is how the function works: it creates a list \texttt{possibleDisplacements} of the 8 possible displacements (all the sign combinations of \((\pm1, \pm1)\) and \((\pm2, \pm2)\)), it deletes all the illegal displacements, and then it returns it (as the list of all legal displacements called \texttt{legalDisplacements}). \\
	That was the big picture of \texttt{getLegalDisplacements}, but the implementation has been optimised and tweaked little bit as you can see in algorithm \ref{alg:getlegaldisplacements}.\\
	\begin{algorithm}[h]
		\label{alg:getlegaldisplacements}
		possibleDisplacements = []\\
		// use a multiplier to change the rows depending on which side the playeris facing\\
		mult = 1\\
		\If{player.isFacingUp}{
			mult = -1\\
		}
		// add displacements to possibleDisplacements \\
		\If{not mustEat}{
			possibleDisplacements.append((1 * mult, -1))\\
			possibleDisplacements.append((1 * mult, 1))\\
		}
		possibleDisplacements.append((2 * mult, -2))\\
		possibleDisplacements.append((2 * mult, 2))\\
		\If{piece.player is king}{
			\If{not mustEat}{
				possibleDisplacements.append((-1 * mult, -1))\\
				possibleDisplacements.append((-1 * mult, 1))\\
			}
			possibleDisplacements.append((-2 * mult, -2))\\
			possibleDisplacements.append((-2 * mult, 2))\\
		}
		// remove illegal displacements\\
		legalDisplacements = []\\
		\For{each displacement in possibleDisplacements}{
			\If{destination is inside the board and is not occupied}{
				\If{displacement is \((\pm2, \pm2)\)}{
					\If{you eat an opponent piece}{
						add displacement to legalDisplacements\\
					}
				}
				\Else{
					add displacement to legalDisplacements\\
				}
			}
		}
		return legalDisplacements\\
		\caption{\texttt{replay}}
	\end{algorithm}
	From there it can be noted that \texttt{possibleDisplacements} does not have all 8 displacements, but only the ones possible depending on rank and \texttt{mustEat}. Also, every row is multiplied by $-1$ if the player is facing the board so that the closest row to him is the 8th.\\
	After that, only the legal displacements between those are kept and returned. Because element shouldn't be removed from a list while it is iterated, another list, \texttt{lagaleDisplacements}, had to be used, be the concept remains the same.
	
	\subsection{Game loop}
	The game is player in a while loop that runs until there is a winner. The steps inside this loop are the following:
	\begin{enumerate}
		\item get a list of all movable pieces;
		\item select an action (move, undo, redo, replay, none (if no movement are available));
		\item perform the action;
		\item calculate next player.
	\end{enumerate}
	
	\subsubsection{Prelude}
	\label{subsubsec:prelude}
	Before the game loop begins, the game has to be set up:
	\begin{enumerate}
		\item the empty board is created;
		\item the players are created;
		\item the pieces are created and placed on the board (using the same algorithm for both sides, but tweaked with a row multiplier, like in algorithm \ref{alg:getlegaldisplacements});
		\item the empty stacks \texttt{moves} and \texttt{redoMoves} are created;
		\item one of the players is set as current player.
	\end{enumerate}
	
	\subsubsection{Getting all movable pieces}
	At the beginning of the game loop a list of \texttt{(pieceCoordinate, [displacements])} is created by using the function \texttt{getLegalDisplacements} for each current player's pieces. When creating this list the program also remembers two things (as booleans): if at least one piece can eat (\texttt{mustEat}) and if there are no possible moves (\texttt{canMove}).\\
	In checkes, if a player have the possibility to eat an opponent piece she must do so: if \texttt{mustEat} is true the movable pieces are recalculated, but tis time the function \texttt{getLegalDisplacements} will be forced to return displacements of \((\pm2, \pm2)\).\\
	The list of all movable pieces is used not only for an easier check of the player's input, but also to help the player deciding what to do, by printing a board that highlights all the pieces that can be moved.
	
	\subsubsection{Selecting an action (move, undo, redo, etc.)}
	The player is now able to select an action: move a selected piece (if \texttt{canMove == True}), undo (if \texttt{len(moves) > 0}), redo (if \texttt{len(redoMoves) > 0}), replay or nothing (if \texttt{canMove == False}).\\
	An action is stored as an enumarated value of the class \texttt{ActionType}.\\
	If the player is not human there are only two possible choices: move or nothing.
	
	\subsubsection{Perform the action}
	Every action is then performed depending on the player's choice:
	\begin{itemize}
		\item move: player must select a legal destination and the move is stored (also, \texttt{redoMoves} is emptyed). If the player can eat again after the moving he must do so;
		\item undo , redo, replay: simply call the corresponding function;
		\item nothing.
	\end{itemize}
	Initally, when the only action coded was \textit{move}, the next player would have been very easy to caculalte. Algorithm \ref{alg:nextplayerold} shows how it was done.
	\begin{algorithm}[h]
		\label{alg:nextplayerold}
		\While{there is not a winner}{
			\For{each player}{
				select move\\
				perform move\\
			}
		}
		\caption{Old game loop}
	\end{algorithm}
	This had to be changed by removing the for each loop and calculating the next player every time an action is performed (see section \ref{subsubsec:nextplayer} \textit{Next player}) .
	
	\subsubsection{Next player}
	\label{subsubsec:nextplayer}
	Because this program supports undo and redo, calculating who the next player is is not straightforward.\\
	This is how it is calculated depending on the action performed (note that this is executed \textit{after} the action):
	\begin{itemize}
		\item move: the other player;
		\item undo: the player of the last move in \texttt{redoMoves};
		\item redo: the player of the last move in \texttt{moves};
		\item replay: the same player, because when the replay is over it will still be the turn of the player who called the function;
		\item nothing: the other player.
	\end{itemize}

	\subsection{AI}
	The \texttt{Player} class has two functions that return the coordinates of a random valid piece that can move and a random valid move. This functions are called when the cpu player is choosing its move.\\
	
	\section{Future work}
	The board may be implemented by using a graph insted of a 2D list. Because the pieces in checkers can only be in black squares, it would make sense to consider each black square a node which edges connect to the (up to) 4 diagonal black squares.
	
	\section{Conclusion}
	It have been very useful to plan the data structures used ahead, because they can be difficult to amend once in the code, expecially if the language used is not Python, which uses lists only.
		
\end{document}